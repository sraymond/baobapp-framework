<?php
/* vim: set expandtab tabstop=4 shiftwidth=4: */
/**
 *
 * @author Stéphane Raymond
 * @version 1.0
 * @package core.controler
 * @copyright Copyright (c) 2009-2099 Stéphane Raymond
 */
abstract class controler extends core {

    /**
     *
     * @var array : save class
     */
    private $_load_getModel = array();

    /**
	 * the curent package name
	 * @var string
	 */
	protected $package_name = null;
	
	/**
	 * view class of the curent package call
	 * @var view
	 */
	protected $view = null;
	
	/**
	 * model class of the curent package call
	 * @var model
	 */
	protected $model = null;

	/**
	 * observer object injected
	 * @object $observer
	 */
	protected $observer = null;

	/**
     * Instanciate the view and the model of the curent package
     */
	public function __construct() {
        if (
            file_exists(RESSOURCE_PACKAGE_PATH . '/'.$this->package_name.'/'.$this->package_name.'_view.php') !== true || 
            file_exists(RESSOURCE_PACKAGE_PATH . '/'.$this->package_name.'/'.$this->package_name.'_model.php') !== true ) {
            throw new Exception(__('Pour utiliser le package "'.$this->package_name.'" : la vue et le model doivent avoir été déclaré au préalable même si ils n\'ont aucune méthodes.'), 500);
        }
        $this->setView();
        $this->setModel();
    }

	/**
	 * All package need to have a home action and a view asociated
     *
     * Pour chaque package, il faut impérativement définir l'action home donc la méthode home(){}
	 */
	abstract protected function home();

	/**
	 * You need to define a right rule in each controler package. Do not forget that you choose !
     * An exemple is include on the distribution package
     *
     * Il faut pour chaque package définir la gestion des droits. Par défaut, il suffit de créer
     * la fonction. Le contenu de cette dernière sera en fonction de votre gestion des accès qui sera à coder
     * dans la méthode checkRights(){}
	 * @return array Cette fonction retourne un tableau de droits action => droits
	 */
	abstract protected function _rights();
	
	/**
     * decide how the user can have an access to this action. You can over write in your application
     * or just use this one : ever true so the user can see the result of the call.
     *
     * Le controle d'accès peut être redéfinit dans l'application elle même. Vous
     * pouvez re définir la gestion des accès pour chaques applications
     * 
     * @param string $action
     * @return boolean true by default : you have full access to the action
     */
    protected function checkRight($action) {
        return true;
    }
	
	/**
     * This methode is a workflow and display the content generated by the view after a user call.
     * Before retuning the result, the methode made some check :
     * - Action exist ?
     * - Check rights ? does the user access to this action ?
     * - if evrythings are ok, then execute the call action and allocate the outup variable  $this->view->toString
     *
     * Cette méthode est un workflow qui va retourner au bootstrap le contenu (html, json, txt ,...)
     * qui aura été généré par l'action de l'utilisateur. Avant de retourner le contenu,
     * une série de vérifications s'imposent :
     * - L'action existe-t-elle ?
     * - Est ce que l'utilisateur a les autorisation pour accéder à cette ressource ?
     * - Estc e que l'action existe ?
     * 
     * @param boolean $call_package
     * @param string $call_package_param
     * @return mixed : throw exception Or return an html string
     */
	public function display($call_package = false,$call_package_param = array()) {
        
	    if($call_package === true) {
            $action = $call_package_param['_a'];
            $this->allocatePostGetVariable($call_package_param);
        }else {
            $action = $this->observer['param']['_a'];
        }

		$this->checkRight($action);
        
        $methods = $this->getAllowedMethods();
			
		if (in_array($action, $methods,true) !== true) {
            throw new Exception(_('This action "'.$action.'" does not exist for the package "'.$this->package_name.'"'), 500);
        }
        
        $this->$action();

        $result = ($this->view ? $this->view->toString($call_package) : '!');
		return $result;	
	}

    /**
     * Push variables on the _GET and _POST
     *
     * Permet de mettre dans les super global GET et POST des valeurs
     * C'est une manière de simuler des POST ou des GET entre package : voir utilisation de callPackage()
     *
     * @param array $param
     * @example array('_GET'=>array('foo'=>'bar')); echo $_GET['foo']; display bar
     */
    public function allocatePostGetVariable($param) {
        $this->_allocatePostGetVariable($param);
    }

    /**
     * Init the observer result in the object
     *
     * Rend disponible les résultats de l'objet observer
     * 
     * @param array $ressource
     */
    public function setObserverResult($ressource) {
        $this->observer = $ressource;
    }

    /**
     * Return the observer result
     *
     * Retourne les valeurs de l'observer
     * 
     * @return array
     */
    public function getObserverResult() {
        return $this->observer;
    }

    /**
     * Set the package name. Allow you to load the model and the view associated
     *
     * Initialise le nom du package courant permettant de charger le model et la vue associé
     *
     * @param string $package_name
     */
    public function setPackageName($package_name) {
        $this->package_name = $package_name;
    }

    /**
     * return the name of the curent package
     *
     * Retourne le nom du package courant
     * 
     * @return string
     */
    public function getCurentPackageName() {
        return $this->package_name;
    }

    /**
     * Set the view of the curent package
     *
     * Initialise l'objet vue du package courant
     * 
     * @return object view
     */
    public function setView() {
        $this->view = $this->_instanciateObject($this->package_name . '_view');
        return $this->view;
    }

    /**
     * Return the view of the curent package
     *
     * Retourne l'objet vue du package courant
     * 
     * @return object view
     */
	final protected function getView() {
        return $this->view;
	}

    /**
     * Set the model object for the curent package
     *
     * Initialise le model du package courant
     */
    public function setModel() {
        $this->_load_getModel[$this->package_name] = $this->model = $this->_instanciateObject($this->package_name . '_model');
    }

    /**
     * Unset the curent package object model
     *
     * Désinstancie l'objet model du package courant
     * 
     * @param string $package_name
     */
    public function removeModel($package_name) {
        if(isset($this->_load_getModel[$package_name])) {
            unset($this->_load_getModel[$package_name]);
        }
    }

    /**
     * Allow you to call an other package object model
     *
     * Permet d'utiliser un autre model d'un autre package
     * 
     * @param string $package_name : name of the package call / Nom du package souhaité
     * @param boolean $force if set to true and the $package_name seted, then force to reinstanciate the package model /
     * Si setté à true et que le nom du package est définit, alors on ré instancie le model même si ce dernier existe
     * 
     * @return object
     */
    protected function getModel($package_name = '',$force = false) {
        
        switch ($package_name) {
            case '':
                if(!isset($this->_load_getModel[$this->package_name])){
                    $this->setModel();
                }
                return $this->model;
                break;
            default:
                if(isset($this->_load_getModel[$package_name]) && $force === false) {
                    return $this->_load_getModel[$package_name];
                }
                $this->_load_getModel[$package_name] = $this->_instanciateObject($package_name . '_model');
                return $this->_load_getModel[$package_name];
                break;
        }
    }

    /**
     * Instanciate a class
     *
     * Instancie une class
     * 
     * @param string $name
     * @return object
     */
    private function _instanciateObject($name) {
        return new $name();
    }

    /**
     * Allow to push in $_POST and $_GET somme key value when using call_package
     *
     * Initialise dans GET et POST des clefs=>valeurs
     * @param array $param
     */
    private function _allocatePostGetVariable($param) {
        if(is_array($param['_GET']) && count($param['_GET']) > 0) {
            foreach ($param['_GET'] as $clef => $value) {
                if(isset($_GET[$clef])) {
                    $_GET['package_' . $clef] = $value;
			    }else {
                    $_GET[$clef] = $value;
			    }
			}
	    }
		if(is_array($param['_POST']) && count($param['_POST']) > 0) {
            foreach ($param['_POST'] as $clef => $value) {
                if(isset($_POST[$clef])) {
                    $_POST['package_' . $clef] = $value;
			    }else {
                    $_POST[$clef] = $value;
			    }
			}
		}
    }
}
?>